
/*
void  read_dir(char *path){
    DIR           *d;
    struct dirent *dir;
    //int dir_num = 0;
    //char dir_str[100]="\0";
    strcpy(dir_str,"\0");
    if ((d = opendir(path))){
        while ((dir = readdir(d)) != NULL){
            strcat(dir_str, dir->d_name);
            //strcpy(dir_list[dir_num++],dir->d_name); 
            //strcat(dir_str,",");
        }
        closedir(d);
    }
    //return(dir_num);
}

else{ //other command
            //printf("check command start\n");
            //if(strcspn(dir_strm,mds[cmd_index].com_str[0])!=strlen(dir_str)){}
            //else{}
            for (i=0; i<dir_num; i++){
                if(strcmp(cmds[cmd_index].com_str[0], dir_list[i])==0 ){//legal command
                    
                     fork 
                    cmdchildpid=fork();
                    
                    if(cmdchildpid<0){
                        perror("fork error");
                    }
                    else if(cmdchildpid==0){//child process
                         set execvp_str 
                        execvp_str[0] = cmds[cmd_index].com_str[0];    //execvp_str[0] = &(cmds[cmd_index].com_str[0][0]);
                        for(j=1; j<cmds[cmd_index].para_len; j++){
                            execvp_str[j] = cmds[cmd_index].com_str[j];
                        }
                        execvp_str[j]=NULL;
                        
                        if(strcmp(cmds[cmd_index].output_file, "\0") != 0){ // if find '>' 
                            FILE * f =fopen(cmds[cmd_index].output_file,"w");
                            f_d = fileno(f);
                        }
                        
                         set input 
                        if(inputflag[index_count] == 1){//have data in pipe for this cmd
                            //printf("%s:someone output to this command \n",cmds[cmd_index].com_str[0]);
                            dup2(pipe_fd[index_count][0], STDIN_FILENO);
                            close(pipe_fd[index_count][1]);
                        }

                         set output to where 
                        if( cmds[cmd_index].output_to>0 ){
                            dup2(pipe_fd[index_count_output][1], STDOUT_FILENO);
                            printf("%s:cmds[cmd_index].output_to>0\n",cmds[cmd_index].com_str[0]);
                            sprintf(temp,"%s pipe into %d\n",cmds[cmd_index].com_str[0],pipe_fd[cmd_count+cmd_index+cmds[cmd_index].output_to][1]);
                            write(pipe_fd[cmd_count+cmd_index+cmds[cmd_index].output_to][1],temp,strlen(temp));
                            
                        }
                        else if(f_d > 0){
                            //printf("cmd_index=%d,%s:f_d > 0\n",cmd_index,cmds[cmd_index].com_str[0]);
                            dup2(f_d, STDOUT_FILENO);
                        }
                        else{
                            //printf("%s:printf to socket\n",cmds[cmd_index].com_str[0]);
                            dup2(newsockfd, STDOUT_FILENO);
                        }
                        
                         always print error to client 
                        dup2(newsockfd, STDERR_FILENO);
                        
                         execvp 
                        if (execvp(execvp_str[0],execvp_str) <0 ){
                            perror("error on exec");
                            exit(0);
                        }
                    }
                    else{//parent process
                        if(inputflag[index_count] == 1){
                            close(pipe_fd[index_count][0]);
                            close(pipe_fd[index_count][1]);
                        }
                        waitpid(cmdchildpid, &status,0);
                    }
                    
                    i=dir_num+1;//jump over unknown command
                    break;
                }
            }//printf("check command finish,i=%d,\n",i);

            if(i==dir_num){ //illegal command
                sprintf(temp, "Unknown command: [%s].\n",cmds[cmd_index].com_str[0]);
                write(newsockfd, temp, strlen(temp));//printf("temp=%s",temp);
            }
        }
*/

void exe_cmds(int cmd_index,int newsockfd,int cmd_count){
    char * execvp_str[ cmds[cmd_index].para_len +2 ];
    int i,j;
    int f_d=0;
    int status;
    int cmdchildpid;
    char temp[100];
    /* fork */
    cmdchildpid=fork();
    
    if(cmdchildpid<0){
        perror("fork error");
    }
    else if(cmdchildpid==0){//child process
        /* set execvp_str */
        execvp_str[0] = &(cmds[cmd_index].com_str[0][0]);
        for(j=1; j<cmds[cmd_index].para_len; j++){
            execvp_str[j] = &cmds[cmd_index].com_str[j][0];
        }
        execvp_str[j]=NULL;
        
        if(strcmp(cmds[cmd_index].output_file, "\0") != 0){ // if find '>' 
            FILE * f =fopen(cmds[cmd_index].output_file,"w");
            f_d = fileno(f);
        }
        
        
        /* set input */
        if(inputflag[cmd_count+cmd_index] == 1){//have data in pipe for this cmd
            printf("%s:someone output to this command \n",cmds[cmd_index].com_str[0]);
            dup2(pipe_fd[cmd_count+cmd_index][0], STDIN_FILENO);
            close(pipe_fd[cmd_count+cmd_index][1]);
        }

        /* set output to where */
        if( cmds[cmd_index].output_to>0 ){
            printf("%s:cmds[cmd_index].output_to>0\n",cmds[cmd_index].com_str[0]);
            i=cmd_count+cmd_index+cmds[cmd_index].output_to;
            dup2(pipe_fd[i][1], STDOUT_FILENO);
            sprintf(temp,"%s pipe into %d\n",cmds[cmd_index].com_str[0],pipe_fd[i][1]);
            write(pipe_fd[i][1],temp,strlen(temp));
        }
        else if(f_d > 0){
            printf("cmd_index=%d,%s:f_d > 0\n",cmd_index,cmds[cmd_index].com_str[0]);
            dup2(f_d, STDOUT_FILENO);//maybe error
        }
        else{
            printf("%s:printf to socket\n",cmds[cmd_index].com_str[0]);
            dup2(newsockfd, STDOUT_FILENO);
        }
        
        /* always print error to client */
        dup2(newsockfd, STDERR_FILENO);
        
        /* execvp */
        if (execvp(execvp_str[0],execvp_str) <0 ){
            perror("error on exec");
            exit(0);
        }
    }
    else{//parent process
        if(inputflag[cmd_count+cmd_index] == 1){
            close(pipe_fd[cmd_count+cmd_index][0]);
            close(pipe_fd[cmd_count+cmd_index][1]);
        }
        waitpid(cmdchildpid, &status,0);
        
    }
}



/*//store garbage
int cut_pip(char inputbuf[10000],int cmd_count){
    int  i=0,j,k,space_index;
    char temp[100];
    char *test = strtok(inputbuf, "|");
    memset(cmds, 0, sizeof(cmds));
    int total_com_num = 0;
    
    
    //cut string by '|'
    while (test != NULL){
        if(test)
        strncpy(cmds[total_com_num++].com_str[0], test, strlen(test));
        test = strtok(NULL, "|");
    }
    
    // what number after '|'
    i=0;
    while(cmds[i].com_str[0][0]!='\0'){
        cmds[i].output_to_bytes = 0;
       
        if( i>0 ){
            cmds[i-1].output_to =1;
        }

        while(47 < cmds[i].com_str[0][cmds[i].output_to_bytes] && cmds[i].com_str[0][cmds[i].output_to_bytes] < 58)
            cmds[i].output_to_bytes++;
        
        if(cmds[i].output_to_bytes >0){
            strncpy(temp, cmds[i].com_str[0], cmds[i].output_to_bytes);
            cmds[i-1].output_to = atoi(temp);
        }
        i++;
    }
    printf("1.\n");
    ptfallcmd(cmd_count);

    // clear the number from command 
    i=0;
    while(cmds[i++].com_str[0][0]!='\0'){
        for(j=0; cmds[i].com_str[0][cmds[i].output_to_bytes+1+j]!='\0'; j++){
            cmds[i].com_str[0][j] = cmds[i].com_str[0][cmds[i].output_to_bytes+1+j];
        }

        // 4 line after this line, to clear the space in the end of line
        if(cmds[i].com_str[0][j-1]==' '){
            cmds[i].com_str[0][j-1]='\0';
        }
        else{
            cmds[i].com_str[0][j]='\0';
        }
    }
    printf("2.\n");
    ptfallcmd(cmd_count);
    // split command and para 
    i=0;
    while(cmds[i].com_str[0][0]!='\0'){
        j=0;k=0;space_index = 0;
        
        while(cmds[i].com_str[0][++space_index] != ' ' && space_index<strlen(cmds[i].com_str[0]));//find the first ' '
        if(cmds[i].com_str[0][space_index+1] != '\0' && cmds[i].com_str[0][space_index+1] != ' ')
            for(j=space_index;j<strlen(cmds[i].com_str[0]);j++)
                if(cmds[i].com_str[0][j] == ' '){
                    if(cmds[i].com_str[0][j+1] != '\0')
                        cmds[i].para_len++;
                    k=0;
                }
                else
                    cmds[i].com_str[cmds[i].para_len][k++]=cmds[i].com_str[0][j];

        cmds[i].com_str[0][space_index]='\0';
        i++;
    }
    
    if(cmds[total_com_num-1].com_str[0][0]==0){
        cmds[total_com_num-1].com_str[0][0]='\0';
        total_com_num--;
    }
    return(total_com_num);
}



/*if(pipe(skt_fd) == -1){
        perror( "socket pipe error");
        exit(EXIT_FAILURE);
    }*/
            strcpy(cmds[cmd_index].output_str,cmds[cmd_index].com_str[1]);
            strcat(cmds[cmd_index].output_str,"=");
            strcat(cmds[cmd_index].output_str,getenv(cmds[cmd_index].com_str[1]));
            strcat(cmds[cmd_index].output_str,"\n");*/
            /*if(cmds[cmd_index].output_to==0)
                strcat(outputBuffer,cmds[cmd_index].output_str);
if(strcmp(cmds[cmd_index].com_str[0],"ls") == 0 || strcmp(cmds[cmd_index].com_str[0],"noop") == 0){}
else{
    strcpy(temp, cmds[cmd_index].com_str[cmds[cmd_index].para_len]);
    printf("exe_cmd:%s,\n",temp);
    FILE *file = fopen(".temp", "w");
    fwrite(temp, sizeof(temp), 1,file);
    fclose(file);
    strcpy(execvp_str[++j] , ".temp");
    j++;
}
//
    //dup2(pipe_fd[cmd_index+cmd_count][1], STDOUT_FILENO);//redirect
    /*check previout command if  has output to this command*/    
    //for(i=0; i < cmd_index; i++){
    //    if(cmd_index == i+cmds[i].output_to){
    //        strcpy(cmds[cmd_index].com_str[cmds[cmd_index].para_len++], cmds[i].output_str);
    //    }
    //}
    
    
    //strcpy(temp,cmds[i].output_str);
                //test = strtok(temp, " ");
                //while(test!=NULL){
                //    strcpy(cmds[i].com_str[cmds[i].para_len++] ,test);
                //    test = strtok(NULL," ");
                //}
                
void  parse(int cmd_index, char **argv){
    char temp[256]="";
    char *line;
    //strcat(temp,cmds[cmd_index].com_str);
    //if(cmds[cmd_index].para[0] != '\0'){
    //    strcat(temp," ");
    //    strcat(temp,cmds[cmd_index].para);
    //}
    line = &temp[0];
    
    while (*line != '\0') {      // if not the end of line ....... 
        while (*line == ' ' || *line == '\t' || *line == '\n')
            *line++ = '\0';     / replace white spaces with 0    
        *argv++ = line;          / save the argument position     
        while (*line != '\0' && *line != ' ' && 
            *line != '\t' && *line != '\n') 
        line++;              skip the argument until ...    
    }
    *argv = '\0';                  mark the end of argument list  
}
    // all commands    
    if(     strcmp(cmds[cmd_index].com_str[0],"ls")==0){
        if (execvp("ls",execvp_str) <0 ){
            perror("error on exec");
            exit(0);
        }
    }
    else if(strcmp(cmds[cmd_index].com_str[0],"cat")==0){
        if (execvp("cat",execvp_str) <0 ){
            perror("error on exec");
            exit(0);
        }
    }
    else if(strcmp(cmds[cmd_index].com_str[0],"removetag")==0){}
    else if(strcmp(cmds[cmd_index].com_str[0],"removetag0")==0){}
    else if(strcmp(cmds[cmd_index].com_str[0],"number")==0){}
    else if(strcmp(cmds[cmd_index].com_str[0],"noop")==0){}
    
            cmds[i].com_str[i][++space_index]!=' ' && space_index<strlen(cmds[i].com_str[0])){
            while()
        
        
        j=0;
        space_index = 0;
        for(k=0; k<strlen(cmds[i].com_str[0]); k++){
            while(cmds[i].com_str[0][++space_index] != ' ' && space_index<strlen(cmds[i].com_str[0]));//find the space in com_str
            for(j=0; j+space_index<strlen(cmds[i].com_str[0]); j++)
                cmds[i].para[j]=cmds[i].com_str[space_index+1+j];
            cmds[i].com_str[space_index]='\0';
        }
        i++;
    }
        
    void str_echo(int sockfd){
    int n;
    char line[MAXLINE];

    for(;;){
        n = readline(sockfd, line, MAXLINE);
        if(n==0)
            return;
        else if(n<0)
            printf("str_echo : readline error");

        if(write(sockfd, line, n) !=n)
            printf("str_echo : writen error");
    }
}
    //else
    //    printf("socket create successful ,%d\n",sockfd);
        
    //strcpy(inputBuffer, "autoremovetag test.html | number |1 list |23 number |456 balabala");
    else{//parent process
        wait(&clientchildpid);
        printf("execvp done\n\n");
        printf("parent process");
    }
    
    clientchildpid=fork();
    if(clientchildpid<0)
        perror("fork error");
    
    else if (clientchildpid == 0){ //child process
        char * execvp_str[] = {"echo", "executed by execvp",">>", "~/abc.txt",NULL};  
        if (execvp("echo",execvp_str) <0 ){  
            perror("error on exec");  
            exit(0);  
        }
    }else{ //parent process
        wait(&clientchildpid);
        printf("execvp done\n\n");
    }
    */
